=encoding utf8

=head1 数组

Z<arrays>
X<arrays>
X<first-class>

Perl 5 I<数组> 是存放零个或多个标量的数据结构。它们是 I<一等> 数据结构，意味着 Perl 5 在语言级别提供了
单独的数据类型。数组支持下标访问，即，你可以按整数下标访问某数组中每一个独立的成员。

C<@> 印记是数组的标识。要想声明一个数组：

=begin programlisting

    my @items;

=end programlisting

=head2 数组元素

X<variant sigils>
X<sigils; variance>

在 Perl 5 中 I<访问> 数组中独立的元素要求标量印记。Perl 5（和你）可以识别出 C<$cats[0]> 指的是 C<@cats> 数组
而不必理会印记的改动，因为中括号（C<[]>）始终标明对集合变量的下标访问。用简单的话来说，意思就是“通过一个整数
在一组东西里查找某件东西”。

数组中第一个元素的下标为零：

=begin programlisting

    # @cats 包含一列 Cat（猫）对象
    my $first_cat = $cats[0];

=end programlisting

数组中最后一个元素的下标取决于数组中元素的个数。标量上下文中的数组（因标量赋值、字符串拼接、加法或布尔上下文）
求值得出数组中所含元素的个数：

=begin programlisting

    # 标量赋值
    my $num_cats = @cats;

    # 字符串拼接
    say 'I have ' . @cats . ' cats!';

    # 加法 
    my $num_animals = @cats + @dogs + @fish;

    # 布尔上下文
    say 'Yep, a cat owner!' if @cats;

=end programlisting

如果你需要得到最后一个元素指定的下标，将数组元素的个数减去一即可（因为数组下标从零开始）：

=begin programlisting

    my $first_index = 0;
    my $last_index  = @cats - 1;

    say   'My first cat has an index of $first_index, '
        . 'and my last cat has an index of $last_index.'

=end programlisting

你也可以使用数组的特殊变量形式来找出最后一个下标，将 C<@> 数组印记替换为更为笨拙的 C<$#>：

=begin programlisting

    my $first_index = 0;
    B<my $last_index  = $#cats;>

    say   'My first cat has an index of $first_index, '
        . 'and my last cat has an index of $last_index.'

=end programlisting

然而，读上去可能不那么好。大多数时间你不会需要那种用法，因为你还可以使用负偏移量从末尾而不是
开头访问一个数组。数组的最后一个元素可以由下标 C<-1> 取到。倒数第二个元素可以用下标 C<-2>，等等。
例如：

=begin programlisting

    my $last_cat           = $cats[-1];
    my $second_to_last_cat = $cats[-2];

=end programlisting

你可以通过对 C<$#> 赋值来调整数组大小。如果你对数组进行收缩，Perl 将丢弃所有不符合调整后尺寸的值。
如果你扩展一个数组，Perl 将把 C<undef> 填入多出来的位置。

=head2 数组赋值

你可以通过对某下标位置直接对数组赋值：

=begin programlisting

    my @cats;
    $cats[0] = 'Daisy';
    $cats[1] = 'Petunia';
    $cats[2] = 'Tuxedo';
    $cats[3] = 'Jack';
    $cats[4] = 'Brad';

=end programlisting

Perl 5 的数组是可变的。它没有静态尺寸，它会按需扩展和收缩。

=begin sidebar

你不也必按顺序赋值。如果你对超出范围的位置赋值的话，Perl 会将数组扩展到合适的大小，
并向夹在中间的所有空槽都填入 C<undef>。

=end sidebar

多行赋值太过冗长。你可以用列表对一个数组进行一步到位的初始化：

=begin programlisting

    my @cats = ( 'Daisy', 'Petunia', 'Tuxedo', 'Jack', 'Brad' );

=end programlisting

=begin sidebar

注意括号 I<并不> 创建一个列表。没有了括号，根据操作符优先级（L<precedence>），C<Daisy> 将赋
值成为数组的第一个也是唯一一个元素。

=end sidebar

任何在列表上下文中产生列表的表达式可以对数组进行赋值：

=begin programlisting

    my @cats     = get_cat_list();
    my @timeinfo = localtime();
    my @nums     = 1 .. 10;

=end programlisting

对数组的标量元素赋值将施加标量上下文，对数组整体进行赋值则施加列表上下文。

要清空一个数组，用空列表对其赋值：

=begin programlisting

    my @dates = ( 1969, 2001, 2010, 2051, 1787 );
    ...
    @dates    = ();

=end programlisting

=begin sidebar

由于新声明的数组起始为空，C<my @items = ();> 便成为了 C<my @items> 的加长版。请使用后者。

=end sidebar

=head2 数组分片

X<array slice>
X<slices; array>

你也可以通过一个名为 I<数组分片> 的语法结构在列表上下文中访问一个数组。不同于对某数组元素
进行标量访问，此操作使用一列下标以及数组印记（C<@>）：

=begin programlisting

    my @youngest_cats = @cats[-1, -2];
    my @oldest_cats   = @cats[0 .. 2];
    my @selected_cats = @cats[ @indexes ];

=end programlisting

你也可以对一个数组分片进行赋值：

=begin programlisting

    @users[ @replace_indices ] = @replace_users;

=end programlisting

一个分片可以包含零个或多个元素────包括一个：

=begin programlisting

    # 单元素数组分片，I<列表> 上下文中的函数调用
    @cats[-1] = get_more_cats();

    # 单元素数组访问，I<标量> 上下文中的函数调用
    $cats[-1] = get_more_cats();

=end programlisting

数组分片和单元素访问之间唯一的语法区别就是开头的印记。I<语义> 区别就比较大了：
一个数组分片总是强制列表上下文。任何在标量上下文中求值的数组分片都会引发错误：

=begin screen

    Scalar value @cats[1] better written as $cats[1] at...

=end screen

数组分片对用于下标的表达式强制列表上下文（L<context_philosophy>）：

=begin programlisting

    # 函数调用于列表上下文
    my @cats = @cats[ get_cat_indices() ];

=end programlisting

=head2 数组操作

管理数组下标会是个麻烦。因为 Perl 5 可以按需扩展或收缩数组，语言同时提供了若干操作
以将数组作为栈、队列，等对待。

X<push>
X<builtins; push>
X<pop>
X<builtins; pop>

C<push> 和 C<pop> 操作符各自在数组尾部添加和删除元素：

=begin programlisting

    my @meals;

    # 这里有什么可以吃的？
    push @meals, qw( hamburgers pizza lasagna turnip );

    # ……但是侄儿不喜欢蔬菜
    pop @meals;

=end programlisting

你可以用 C<push> 向数组添加任何数量的元素。它的第二个参数是一个值列表。但你只能用 C<pop> 一次
删除一个元素。C<push> 返回的是更新后数组中元素的个数。C<pop> 返回删除的元素。

X<shift>
X<builtins; shift>
X<unshift>
X<builtins; unshift>

类似的，C<unshift> 和 C<shift> 向数组开头添加和删除元素：

=begin programlisting

    # 扩展我们的烹饪视野
    unshift @meals, qw( tofu curry spanakopita taquitos );

    # 对豆类重新考虑
    shift @meals;

=end programlisting

C<unshift> 将一个含零个或多个元素的列表前置于某数组开头并返回数组中元素最新个数。C<shift> 删除
并返回数组的第一个元素。

=begin sidebar

很少有程序使用 C<push> 和 C<unshift> 的返回值。编写本章催生了一个优化 C<push> 在空上下文中使用
的 Perl 5 补丁。

=end sidebar

X<splice>
X<builtins; splice>

C<splice> 是另一个重要的────可能较少使用────数组操作符。它按给出偏移量、列表分片长度以及
替代物删除并替换数组元素。替换和删除都是可选的，你可以忽略这些行为。C<perlfunc> 中对 C<splice> 
的描述演示了它和 C<push>、C<pop>、C<shift> 及 C<unshift> 的等价性。

数组元素通常在循环中处理。有关 Perl 5 控制流程和数组处理的更多信息，请参见 L<looping_directives>。

X<each>
X<builtins; each>

在 Perl 5.12 中，你可以使用 C<each> 来将某数组迭代为键值对：

=begin programlisting

    while (my ($index, $value) = each @bookshelf)
    {
        say "#$index: $value";
        ...
    }

=end programlisting

=head2 数组和上下文

X<list context; arrays>

在列表上下文中，数组平整为列表。如果你将多个数组传递给一个常规 Perl 5 函数，它们会平整为
单个列表：

=begin programlisting

    my @cats = qw( Daisy Petunia Tuxedo Brad Jack );
    my @dogs = qw( Rodney Lucky );

    take_pets_to_vet( @cats, @dogs );

    sub take_pets_to_vet
    {
        # 不要这样用！
        my (@cats, @dogs) = @_;
        ...
    }

=end programlisting

在此函数内，C<@_> 会包含七个元素而非二。与此类似，数组的列表赋值是 I<贪心的>。一个数组会从列表
中消耗尽可能多的元素。赋值之后，C<@cats> 将包含传递给函数的 I<每一个> 参数。而 C<@dogs> 为空。

平整行为有时会给想要在 Perl 5 中创建嵌套数组的新手带来疑惑：

=begin programlisting

    # 创建单个数组，不是数组的数组
    my @array_of_arrays = ( 1 .. 10, ( 11 .. 20, ( 21 .. 30 ) ) );

=end programlisting

有些人起初会期望这段代码产生一个数组，它的头十个元素是一到十的数字，第十一个元素
是一个数组，包含数字十一到二十以及内嵌另一个包含二十一到三十的数组。注意在这种情
形下括号并不 I<创建> 列表────它只用来给表达式分组。

解决平整问题的方法和给函数传递参数、创建嵌套数组的一样（L<references>）。

=head2 数组内插

X<array interpolation>
X<interpolation; arrays>
X<$">
X<$LIST_SEPARATOR>

数组会作为字符串化的列表内插入双引号字符串，它的每一个元素由神奇的全局变量 C<$">
的当前值分隔。此变量的默认值是一个空格。它的 F<English.pm> 助记形式是 C<$LIST_SEPARATOR>。
因此：

=begin programlisting

    my @alphabet = 'a' .. 'z';
    say "[@alphabet]";
    B<[a b c d e f g h i j k l m n o p q r s t u v w x y z]>

=end programlisting

临时局部化并将另外值赋给 C<$"> 是一个很好的调试用法。N<致谢：Mark-Jason Dominus 在几年前演示了本例中的用法>:

=begin programlisting

    # 这个数组中有什么？
    {
        local $" = ')(';
        say "(@sweet_treats)";
    }

=end programlisting

……这个例子产生如下结果：

=begin screen

    (pie)(cake)(doughnuts)(cookies)(raisin bread)

=end screen
