=encoding utf8

=head1 控制流程 

Z<control_flow>

X<control flow>

Perl 的基本 I<控制流程> 相当直截了当。程序执行过程起始于程序开头（被执行文件的第一行）
然后一直到结尾：

=begin programlisting

    say 'At start';
    say 'In middle';
    say 'At end';

=end programlisting

X<control flow directives>

大多数程序需要更为复杂的控制流程。Perl 的 I<控制流程语句> 改变了程序执行的顺序────程序
中接下来要发生的────依赖于任意复杂的表达式的值。

=head2 分支语句

X<if>
X<control flow directives; if>
X<postfix if>
X<postfix expressions; if>

C<if> 语句对一条件表达式求值并仅在此条件表达式的值为真时执行相关动作：

=begin programlisting

    say 'Hello, Bob!' if $name eq 'Bob';

=end programlisting

这种后缀形式在表达式较简单时很有用。代码块形式则将多个表达式组合成单一单元：

=begin programlisting

    if ($name eq 'Bob')
    {
        say 'Hello, Bob!';
        found_bob();
    }

=end programlisting

注意后缀形式并不 I<要求> 条件两边有括号，但代码块形式则相反。条件表达式也可
以相对复杂：

=begin programlisting

    if ($name eq 'Bob' && not greeted_bob())
    {
        say 'Hello, Bob!';
        found_bob();
    }

=end programlisting

……虽然在此种情况下，采用后缀形式的括号形式可以使其稍显清晰
N<同时也会因此对是否使用后缀形式产生争论>：

=begin programlisting

    greet_bob() if ($name eq 'Bob' && not greeted_bob());

=end programlisting

X<unless>
X<control flow directives; unless>
X<postfix unless>
X<postfix expressions; unless>

C<unless> 语句是 C<if> 的否定形式。Perl 在条件表达式的值为 I<假> 时执行
所需操作：

=begin programlisting

    say "You're no Bob!" unless $name eq 'Bob';

=end programlisting

和 C<if> 类似，C<unless> 也有代码块形式。不同于 C<if>，C<unless> 的代码块形式相比其 
后缀形式来说很少见：

=begin programlisting

    unless (is_leap_year() and is_full_moon())
    {
        frolic();
        gambol();
    }

=end programlisting

C<unless> 很适合后缀条件，特别是函数中的参数验证（L<postfix_parameter_validation>）：

=begin programlisting

    sub frolic
    {
        return unless @_;

        for my $chant (@_)
        {
            ...
        }
    }

=end programlisting

条件一多 C<unless> 就会变得难以阅读，这便是它很少以代码块形式出现的原因之一。

X<else>
X<control flow directives; else>

C<if> 以及 C<unless> 都可以搭配 C<else> 语句，它提供了当条件表达式的值不为真（C<if>）
或假（C<unless>）时运行的代码：

=begin programlisting

    if ($name eq 'Bob')
    {
        say 'Hi, Bob!';
        greet_user();
    }
    else
    {
        say "I don't know you.";
        shun_user();
    }

=end programlisting

C<else> 代码块允许你按不同于自身的方式重写 C<if> 和 C<unless> 条件语句：

=begin programlisting

    B<unless> ($name eq 'Bob')
    {
        say "I don't know you.";
        shun_user();
    }
    else
    {
        say 'Hi, Bob!';
        greet_user();
    }

=end programlisting

如果你大声读出前面这个例子，你会发现一例不合适的伪代码用词：“除非该名字为 Bob，做这件事。否则
做那件。”隐含的双重否定可能会很迷惑。Perl 提供了 C<if> 和 C<unless> 使得你可以按最为自然、
最为上口的方式对条件语句进行组织。同样地，你可以根据比较操作符在肯定和否定断言之间进行选择：

=begin programlisting

    if ($name B<ne> 'Bob')
    {
        say "I don't know you.";
        shun_user();
    }
    else
    {
        say 'Hi, Bob!';
        greet_user();
    }

=end programlisting

因 C<else> 代码块的出现而隐含着的双重否定示意此代码组织方式是不合理的。

X<elsif>
X<control flow directives; elsif>

在单个 C<else> 之前、C<if> 代码块之后可以跟一个或多个 C<elsif> 语句。C<elsif> 代码块的使用数量不限，
但你不可以改变块出现的顺序：

=begin programlisting

    if ($name eq 'Bob')
    {
        say 'Hi, Bob!';
        greet_user();
    }
    elsif ($name eq 'Jim')
    {
        say 'Hi, Jim!';
        greet_user();
    }
    else
    {
        say "You're not my uncle.";
        shun_user();
    }

=end programlisting

你也可以在 C<unless> 链内使用 C<elsif> 块，但是结果代码会不那么清晰。不存在 C<elseunless> 的说法。

同样也没有 C<else if> 这一语法结构 N<Larry 出于美学原因以及 Ada 编程语言的现有技术选择了 C<elsif>>，
因此，这段代码含有语法错误：

=begin programlisting

    if ($name eq 'Rick')
    {
        say 'Hi, cousin!';
    }

    # warning; syntax error
    else if ($name eq 'Kristen')
    {
        say 'Hi, cousin-in-law!';
    }

=end programlisting

=head2 三元条件操作符

X<ternary conditional>
X<control flow directives; ternary conditional>

I<三元条件> 操作符提供了另一种方法来控制流程。它先将条件表达式求值，并由此对两不同结果之一求值：

=begin programlisting

    my $time_suffix = after_noon($time) ? 'morning' : 'afternoon';

=end programlisting

条件表达式位于问号（C<?>）之前，冒号（C<:>）分隔两种选择。这两个选择分支可以是字面值或者（带括号）
任意复杂的表达式，包括其他的三元条件表达式（以可读性为代价）。

=begin sidebar

一个有趣但晦涩的惯用语便是使用三元条件语句在两个候选 I<变量> 之间做出选择，而非仅仅对值：

=begin programlisting

    push @{ rand() > 0.5 ? \@red_team : \@blue_team }, Player->new();

=end programlisting

再次提醒，请对清晰和简略各自带来的利益进行权衡。

=end sidebar

=head3 短路求值

X<short circuiting behavior>
X<short circuiting>

当遇到由多重待求值的表达式组成的复杂表达式时，Perl 将做出名为 I<短路求值> 的行为。如果 Perl
可以决定一个复杂的表达式整体的值是真还是假，那么它不会对后续子表达式求值。用例子说明会更加明白：

=begin programlisting

    say "Both true!" if ok(1, 'first subexpression')
                     && ok(1, 'second subexpression');

=end programlisting

=begin sidebar

C<ok()> 的返回值（L<testing>）是对第一个参数求值得到的。

=end sidebar

这个例子打印出：

=begin screen

    ok 1 - first subexpression
    ok 2 - first subexpression
    Both true!

=end screen

当第一个子表达式────对 C<ok> 的第一次调用────求得真值时，Perl 必须对第二个字表达式求值。
当第一个表达式求得假值时，整个表达式不为真，因此无需检查后续子表达式。

=begin programlisting

    say "Both true!" if ok(0, 'first subexpression')
                     && ok(1, 'second subexpression');

=end programlisting

这个例子打印出：

=begin screen

    not ok 1 - first subexpression

=end screen

虽然第二个子表达式显然为真，Perl 绝不对其求值。对于“一真即真”复杂条件表达式来说，
其逻辑也是相似的：

=begin programlisting

    say "Either true!" if ok(1, 'first subexpression')
                       || ok(1, 'second subexpression');

=end programlisting

这个例子打印出：

=begin screen

    ok 1 - first subexpression
    Either true!

=end screen

再次，第一个子表达式为真，Perl 可以避免对第二个子表达式求值。如果第一个子表达式为假，
则对第二个子表达式求值的结果将决定整个表达式的真假。

除了可以让你避免潜在的昂贵计算，短路求值还可以帮助你避免错误和警告：

=begin programlisting

    if (exists $barbeque{pork} and $barbeque{pork} eq 'shoulder') { ... }

=end programlisting


=head2 条件语句相关的上下文

X<context; conditional>
X<truth>
X<boolean truth>
X<true value>
X<false value>

这些条件语句────C<if>、C<unless>，以及三元条件表达式────总是在布尔上下文（L<context_philosophy>）
中对一个表达式进行求值。由于 C<eq>、C<==>、C<ne> 和 C<!=> 这类操作符在求值时总产生布尔结果，Perl
将其他表达式的求值结果────包括变量和值────强制转换为布尔形式。对空哈希和数组求值得假。

Perl 5 没有单一的真值、也没有单一的假值。任何求值为 0 的数字为假。包括 C<0>、C<0.0>、C<0e0>、
C<0x0> 等等。空字符串（C<''>）以及 C<"0"> 求值得假，但是字符串如 C<"0.0">、C<"0e0"> 等则不然。
惯用语 C<"0 but true"> 在数值上下文中求值得 0，但其值因字符串内容而为真。空列表和 C<undef> 都
为假。空数组和哈希在标量上下文中返回 0，因此它们在布尔上下文中为假。

带有单个元素的数组────即便该元素是 C<undef>────在布尔上下文中求值得真，含任何元素的哈希────
即使是一键一值两个 C<undef>────在布尔上下文中也得真。

=begin sidebar

CPAN 模块 C<Want> 允许你在你的函数内检测布尔上下文。核心编译命令 C<overloading>（L<overloading>、
L<pragmas>）允许你指定自己的数据类型在布尔上下文中求得的值。

=end sidebar

=head2 Looping Directives

Z<looping_directives>

Perl also provides several directives for looping and iteration.

X<foreach>
X<for>
X<looping directives; for>
X<looping directives; foreach>

The I<foreach>-style loop evaluates an expression which produces a list and
executes a statement or block until it has consumed that list:

=begin programlisting

    foreach (1 .. 10)
    {
        say "$_ * $_ = ", $_ * $_;
    }

=end programlisting

This example uses the range operator to produce a list of integers from one to
ten inclusive.  The C<foreach> directive loops over them, setting the topic
variable (C<$_>; see L<default_scalar_variable>) to each in turn.  Perl
executes the block for each integer and prints the squares of the integers.

=begin sidebar

Perl treats the keywords C<foreach> and C<for> interchangeably.  The remainder
of the syntax of the loop determines the behavior of the loop.  Though
experienced Perl programmers tend to refer to the loop with automatic iteration
as a C<foreach> loop, you can use C<for> safely and clearly any place you might
want to use C<foreach>.

=end sidebar

Like C<if> and C<unless>, the C<for> loop has a postfix form:

=begin programlisting

    say "$_ * $_ = ", $_ * $_ for 1 .. 10;

=end programlisting

Similar suggestions apply for clarity and complexity.

You may provide a variable to which to assign the values of the expression in
place of the topic variable:

=begin programlisting

    for my $i (1 .. 10)
    {
        say "$i * $i = ", $i * $i;
    }

=end programlisting

If you do so, Perl will not set the topic variable (C<$_>) to the iterated
values.  Note also that the scope of the variable C<$i> is only valid I<within>
the loop.  If you have declared a lexical C<$i> in an outer scope, that value
will remain outside the loop:

=begin programlisting

    my $i = 'cow';

    for my $i (1 .. 10)
    {
        say "$i * $i = ", $i * $i;
    }

    is( $i, 'cow', 'Lexical variable not overwritten in outer scope' );

=end programlisting

This localization occurs even if you do not redeclare the iteration variable as
a lexical:

=begin programlisting

    my $i = 'horse';

    for $i (1 .. 10)
    {
        say "$i * $i = ", $i * $i;
    }

    is( $i, 'horse', 'Lexical variable still not overwritten in outer scope' );

=end programlisting

=head2 Iteration and Aliasing

X<iteration aliasing>
X<aliasing>
X<aliasing; foreach>
X<aliasing; iteration>

The C<for> loop performs I<aliasing> of the iterator variable to the values in
the iteration such that you can modify values in place during iteration:

=begin programlisting

    my @nums = 1 .. 10;

    $_ **= 2 for @nums;

    is( $nums[0], 1, '1 * 1 is 1' );
    is( $nums[1], 4, '2 * 2 is 4' );

    ...

    is( $nums[9], 100, '10 * 10 is 100' );

=end programlisting

This aliasing also works with the block style C<foreach> loop:

=begin programlisting

    for my $num (@nums)
    {
        $num **= 2;
    }

=end programlisting

... as well as iteration with the topic variable:

=begin programlisting

    for (@nums)
    {
        $_ **= 2;
    }

=end programlisting

You cannot use aliasing to modify I<constant> values, however:

=begin programlisting

    lc for qw( Huey Dewey Louie );

=end programlisting

... as this will throw an exception about modification of read-only values.
There's little point in doing so anyhow.

You may occasionally see the use of C<for> with a single scalar variable to
alias C<$_> to the variable:

=begin programlisting

    for ($user_input)
    {
        s/(\w)/\\$1/g;  # escape non-word characters
        s/^\s*|\s$/g;   # trim whitespace
    }

=end programlisting

=head2 Iteration and Scoping

X<iterator scoping>
X<scope; iterator>
X<my $_>
X<$_; lexical>

Iterator scoping with the topic variable provides one common source of
confusion.  In this case, C<some_function()> modifies C<$_> on purpose.  If
C<some_function()> called other code which modified C<$_> without explicitly
localizing C<$_>, the iterated value in C<@values> would change.  Debugging
this can be troublesome:

=begin programlisting

    for (@values)
    {
        some_function();
    }

    sub some_function
    {
        s/foo/bar/;
    }

=end programlisting

If you I<must> use C<$_> rather than a named variable, lexicalize the topic
variable with C<my $_>:

=begin programlisting

    sub some_function_called_later
    {
        # was $_ = shift;
        B<my> $_ = shift;

        s/foo/bar/;
        s/baz/quux/;

        return $_;
    }

=end programlisting

Using a named iteration variable also prevents undesired aliasing behavior
through C<$_>.

=head2 The C-Style For Loop

X<for loop>

The C-style I<for loop> allows the programmer to manage iteration manually:

=begin programlisting

    for (my $i = 0; $i <= 10; $i += 2)
    {
        say "$i * $i = ", $i * $i;
    }

=end programlisting

You must assign to an iteration variable manually, as there is no default
assignment to the topic variable.  Consequently there is no aliasing behavior
either.  Though the scope of any declared lexical variable is to the body of
the block, a variable I<not> declared explicitly in the iteration control
section of this construct I<will> overwrite its contents:

=begin programlisting

    my $i = 'pig';

    for ($i = 0; $i <= 10; $i += 2)
    {
        say "$i * $i = ", $i * $i;
    }

    isnt( $i, 'pig', '$i overwritten with a number' );

=end programlisting

This loop has three subexpressions in its looping construct.  The first
subexpression is an initialization section.  It executes once, before the first
execution of the loop body.  The second subexpression is the conditional
comparison subexpression.  Perl evaluates this subexpression before each
iteration of the loop body.  When the subexpression evaluates to a true value,
the loop iteration proceeds.  When the subexpression evaluates to a false
value, the loop iteration stops.  The final subexpression executes after each
iteration of the loop body.

This may be more obvious with an example:

=begin programlisting

    # declared outside to avoid declaration in conditional
    my $i;

    for (
        # loop initialization subexpression
        say 'Initializing' and $i = 0;

        # conditional comparison subexpression
        say "Iteration: $i" and $i < 10;

        # iteration ending subexpression
        say 'Incrementing $i' and $i++
    )
    {
        say "$i * $i = ", $i * $i;
    }

=end programlisting

Note the lack of a trailing semicolon at the iteration ending subexpression as
well as the use of the low-precedence C<and>; this syntax is surprisingly
finicky.  When possible, prefer the C<foreach> style loop to the C<for> loop.

All three subexpressions are optional.  You may write an infinite loop with:

=begin programlisting

    for (;;) { ... }

=end programlisting

=head2 While and Until

X<while loop>
X<loops; while>

A I<while> loop continues until the loop conditional expression evaluates to a
boolean false value.  An infinite loop is much clearer when written:

=begin programlisting

    while (1) { ... }

=end programlisting

The means of evaluating the end of iteration condition in a C<while> loop
differs from a C<foreach> loop in that the evaluation of the expression itself
does not produce any side effects.  If C<@values> has one or more elements,
this code is also an infinite loop:

=begin programlisting

    while (@values)
    {
        say $values[0];
    }

=end programlisting

X<destructive update>

To prevent such an infinite C<while> loop, you must perform a I<destructive
update> of the C<@values> array by modifying the array with each loop
iteration:

=begin programlisting

    while (my $value = shift @values)
    {
        say $value;
    }

=end programlisting

X<until loop>
X<loops; until>

The I<until> loop performs the opposite test as the C<while> loop.  Iteration
continues while the loop conditional expression evaluates to false:

=begin programlisting

    until ($finished_running)
    {
        ...
    }

=end programlisting

The canonical use of the C<while> loop is to iterate over input from a
filehandle:

=begin programlisting

    use autodie;

    open my $fh, '<', $file;

    while (<$fh>)
    {
        ...
    }

=end programlisting

Perl 5 interprets this C<while> loop as if you had written:

=begin programlisting

    while (defined($_ = <$fh>))
    {
        ...
    }

=end programlisting

Without the implicit C<defined>, any line read from the filehandle which
evaluated to false in a scalar context--a blank line or a line which contained
only the character C<0>--would end the loop.  The C<readline> (C<< <> >>)
operator returns an undefined value only when it has finished reading lines from
the file.

=begin sidebar

One common mistake is to forget to remove the line-ending characters from each
line; use the C<chomp> keyword to do so.

=end sidebar

Both C<while> and C<until> have postfix forms.  The simplest infinite loop in
Perl 5 is:

=begin programlisting

    1 while 1;

=end programlisting

Any single expression is suitable for a postfix C<while> or C<until>, such as
the classic "Hello, world!" example from 8-bit computers of the early 1980s:

=begin programlisting

    print "Hello, world!  " while 1;

=end programlisting

Infinite loops may seem silly, but they're actually quite useful.  A simple
event loop for a GUI program or network server may be:

=begin programlisting

    $server->dispatch_results() until $should_shutdown;

=end programlisting

X<do; looping>
X<looping; do>

For more complex expressions, use a C<do> block:

=begin programlisting

    do
    {
        say 'What is your name?';
        my $name = <>;
        chomp $name;
        say "Hello, $name!" if $name;
    } until (eof);

=end programlisting

For the purposes of parsing, a C<do> block is itself a single expression,
though it can contain several expressions.  Unlike the C<while> loop's block
form, the C<do> block with a postfix C<while> or C<until> will execute its body
at least once.  This construct is less common than the other loop forms, but no
less powerful.

=head2 Loops within Loops

X<nested loops>
X<loops; nested>

You may nest loops within other loops:

=begin programlisting

    for my $suit (@suits)
    {
        for my $values (@card_values)
        {
            ...
        }
    }

=end programlisting

In this case, explicitly declaring named variables is essential to
maintainability.  The potential for confusion as to the scoping of iterator
variables is too great when using the topic variable.

A common mistake with nesting C<foreach> and C<while> loops is that it is easy
to exhaust a filehandle with a C<while> loop:

=begin programlisting

    use autodie;

    open my $fh, '<', $some_file;

    for my $prefix (@prefixes)
    {
        # DO NOT USE; likely buggy code
        while (<$fh>)
        {
            say $prefix, $_;
        }
    }

=end programlisting

Opening the filehandle outside of the C<for> loop leaves the file position
unchanged between each iteration of the C<for> loop.  On its second iteration,
the C<while> loop will have nothing to read and will not execute.  To solve
this problem, you may re-open the file inside the C<for> loop (simple to
understand, but not always a good use of system resources), slurp the entire
file into memory (which may not work if the file is large), or C<seek> the
filehandle back to the beginning of the file for each iteration (an often
overlooked option):

=begin programlisting

    use autodie;

    open my $fh, '<', $some_file;

    for my $prefix (@prefixes)
    {
        while (<$fh>)
        {
            say $prefix, $_;
        }

        seek $fh, 0, 0;
    }

=end programlisting

=head2 Loop Control

X<loop control>

Sometimes you need to break out of a loop before you have exhausted the
iteration conditions.  Perl 5's standard control mechanisms--exceptions and
C<return>--work, but you may also use I<loop control> statements.

X<next>

The I<next> statement restarts the loop at its next iteration.  Use it when
you've done all you need to in the current iteration.  To loop over lines in a
file but skip everything that looks like a comment, one which starts with the
character C<#>, you might write:

=begin programlisting

    while (<$fh>)
    {
        B<next> if /\A#/;
        ...
    }

=end programlisting

X<last>

The I<last> statement ends the loop immediately.  To finish processing a file
once you've seen the ending delimiter, you might write:

=begin programlisting

    while (<$fh>)
    {
        next if /\A#/;
        B<last> if /\A__END__/
        ...
    }

=end programlisting

X<redo>

The I<redo> statement restarts the current iteration without evaluating the
conditional again.  This can be useful in those few cases where you want to
modify the line you've read in place, then start processing over from the
beginning without clobbering it with another line.  For example, you could
implement a silly file parser that joins lines which end with a backslash with:

=begin programlisting

    while (my $line = <$fh>)
    {
        chomp $line;

        # match backslash at the end of a line
        if ($line =~ s{\\$}{})
        {
            $line .= <$fh>;
            redo;
        }

        ...
    }

=end programlisting

... though that's a contrived example.

X<labels>
X<loops; labels>

Nested loops can make the use of these loop control statements ambiguous.  In
those cases, a I<loop label> can disambiguate:

=begin programlisting

    OUTER:
    while (<$fh>)
    {
        chomp;

        INNER:
        for my $prefix (@prefixes)
        {
            next OUTER unless $prefix;
            say "$prefix: $_";
        }
    }

=end programlisting

If you find yourself nesting loops such that you need labels to manage control
flow, consider simplifying your code: perhaps extracting inner loops into
functions for clarity.

=head2 Continue

X<continue>

The C<continue> construct behaves like the third subexpression of a C<for>
loop; Perl executes its block for each iteration of the loop, even when you
exit an iteration with C<next>.  You may use it with a C<while>, C<until>,
C<with>, or C<for> loop.  Examples of C<continue> are rare, but it's useful any
time you want to guarantee that something occurs for every iteration of the loop
regardless of how that iteration ends:

=begin programlisting

    while ($i < 10 )
    {
        next unless $i % 2;
        say $i;
    }
    continue
    {
        say 'Continuing...';
        $i++;
    }

=end programlisting

=head2 Given/When

Z<given_when>

X<given>

The C<given> construct is a feature new to Perl 5.10.  It assigns the value of
an expression to the topic variable and introduces a block:

=begin programlisting

    given ($name)
    {
        ...
    }

=end programlisting

Unlike C<for>, it does not iterate over an aggregate.  It evaluates its value
in scalar context, and always assigns to the topic variable:

=begin programlisting

    given (my $username = find_user())
    {
        is( $username, $_, 'topic assignment happens automatically' );
    }

=end programlisting

C<given> also lexicalizes the topic variable to prevent accidental
modification:

=begin programlisting

    given ('mouse')
    {
        say;
        mouse_to_man( $_ );
        say;
    }

    sub mouse_to_man
    {
        $_ = shift;
        s/mouse/man/;
    }

=end programlisting

X<when>

X<topicalization>
X<topicalize>

By itself, this feature may seem less than useful.  In combination with
C<when>, it is very useful.  Use C<given> to I<topicalize> a value.  Within the
associated block, multiple C<when> statements match the topic against
expressions using I<smart-match> semantics.  Thus you might code a Rock, Paper,
Scissors game:

=begin programlisting

    my @options = ( \&rock, \&paper, \&scissors );

    do
    {
        say "Rock, Paper, Scissors!  Pick one: ";
        chomp( my $user = <STDIN> );
        my $computer_match = $options[ rand @options ];
        $computer_match->( lc( $user ) );
    } until (eof);

    sub rock
    {
        print "I chose rock.  ";

        given (shift)
        {
            when (/paper/)    { say 'You win!' };
            when (/rock/)     { say 'We tie!'  };
            when (/scissors/) { say 'I win!'   };
            default           { say "I don't understand your move" };
        }
    }

    sub paper
    {
        print "I chose paper.  ";

        given (shift)
        {
            when (/paper/)    { say 'We tie!'  };
            when (/rock/)     { say 'I win!'   };
            when (/scissors/) { say 'You win!' };
            default           { say "I don't understand your move" };
        }
    }

    sub scissors
    {
        print "I chose scissors.  ";

        given (shift)
        {
            when (/paper/)    { say 'I win!'   };
            when (/rock/)     { say 'You win!' };
            when (/scissors/) { say 'We tie!'  };
            default           { say "I don't understand your move" };
        }
    }

=end programlisting

Perl executes the C<default> rule when none of the other conditions match.

=begin sidebar

The CPAN module C<MooseX::MultiMethods> allows another technique to reduce this
code further.

=end sidebar

The C<when> construct is even more powerful; it can match (L<smart_match>)
against many other types of expressions including scalars, aggregates,
references, arbitrary comparison expressions, and even code references.

=head2 Tailcalls

Z<tailcalls>
X<tailcalls>
X<goto>

A I<tailcall> occurs when the last expression within a function is a call to
another function--the return value of the outer function is the return
value of the inner function:

=begin programlisting

    sub log_and_greet_person
    {
        my $name = shift;
        log( "Greeting $name" );

        return greet_person( $name );
    }

=end programlisting

X<optimization; tailcalls>
X<tailcall optimization>

In this circumstance, returning from C<greet_person()> directly to the caller
of C<log_and_greet_person()> is more efficient than returning to
C<log_and_greet_person()> and immediately returning I<from>
C<log_and_greet_person()>.  Returning directly from C<greet_person()> to the
caller of C<log_and_greet_person()> is an optimization known as I<tailcall
optimization>.

Perl 5 will not detect cases where it could perform this optimization
automatically.

=begin sidebar

Heavily recursive code (L<recursion>), especially mutually recursive code, can
quickly consume a lot of memory.  Using tailcalls reduces the memory needed for
internal bookkeeping of control flow, which can make otherwise expensive
algorithms tractable.

=end sidebar
